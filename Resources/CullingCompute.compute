#pragma kernel ClearIndirectArgument
#pragma kernel ComputeFrustumCulling
#pragma kernel ComputeOcclusionCulling

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

float4 _CameraDrawParams;
float4x4 _CameraViewProjection;

uint _StartOffset;
uint _EndOffset;
float3 _Offset;

float4 _HizTexture_TexelSize;
Texture2D<float> _HizTexture;

StructuredBuffer<float3> _AllInstancesPosWSBuffer;

RWStructuredBuffer<uint> _RWVisibleInstancesIndexBuffer;
RWStructuredBuffer<uint> _RWVisibleIndirectArgumentBuffer;

#define _CameraFov _CameraDrawParams.x
#define _CameraDrawDistance _CameraDrawParams.y
#define _CameraDrawSensity _CameraDrawParams.z

[numthreads(1, 1, 1)]
void ClearIndirectArgument(uint3 id : SV_DispatchThreadID)
{
	_RWVisibleIndirectArgumentBuffer[1] = 0;
}

[numthreads(64, 1, 1)]
void ComputeFrustumCulling(uint3 id : SV_DispatchThreadID)
{
	uint instanceIndex = id.x + _StartOffset;
	if (instanceIndex < _EndOffset)
	{
		float3 worldPosition = _AllInstancesPosWSBuffer[instanceIndex] + _Offset;
		float4 positionCS = mul(_CameraViewProjection, float4(worldPosition, 1.0));
		positionCS.xyz = positionCS.xyz / positionCS.w;

		float hash = GenerateHashedRandomFloat(worldPosition * 100);
		float3 frustum = float3(abs(positionCS.xy), 1 - saturate(positionCS.w / _CameraDrawDistance));

		if (frustum.x < 1.0f && frustum.y < 1.0f && frustum.z < 1.0f && hash < frustum.z && hash < _CameraDrawSensity)
		{
			uint index = 0;
			InterlockedAdd(_RWVisibleIndirectArgumentBuffer[1], 1, index);
			_RWVisibleInstancesIndexBuffer[index] = instanceIndex;
		}
	}
}

[numthreads(64, 1, 1)]
void ComputeOcclusionCulling(uint3 id : SV_DispatchThreadID)
{
	uint instanceIndex = id.x + _StartOffset;
	if (instanceIndex < _EndOffset)
	{
		float3 worldPosition = _AllInstancesPosWSBuffer[instanceIndex] + _Offset;
		float4 positionCS = mul(_CameraViewProjection, float4(worldPosition, 1.0));
		positionCS.xyz = positionCS.xyz / positionCS.w;

		float hash = GenerateHashedRandomFloat(worldPosition * 100);
		float3 frustum = float3(abs(positionCS.xy), 1 - saturate(positionCS.w / _CameraDrawDistance));

		if (frustum.x < 1.0f && frustum.y < 1.0f && frustum.z < 1.0f && hash < frustum.z && hash < _CameraDrawSensity)
		{
			uint mips = clamp(log2(positionCS.w * positionCS.w * _CameraFov / 1024), 0, 6);
			uint scale = 1 << mips;
			uint2 uv = (positionCS.xy * 0.5f + 0.5f) * _HizTexture_TexelSize.xy / scale;

			float4 depth;
			depth.x = _HizTexture.mips[mips][uv];
			depth.y = _HizTexture.mips[mips][uv + uint2(1, 0)];
			depth.z = _HizTexture.mips[mips][uv + uint2(1, 1)];
			depth.w = _HizTexture.mips[mips][uv + uint2(0, 1)];

#if defined(SHADER_API_GLCORE) || defined(SHADER_API_GLES) || defined(SHADER_API_GLES3)
			float farDepth = max(depth.x, max(depth.y, max(depth.z, depth.w)));
#else
			float farDepth = 1 - min(depth.x, min(depth.y, min(depth.z, depth.w)));
#endif

			if (positionCS.z < farDepth)
			{
				uint index = 0;
				InterlockedAdd(_RWVisibleIndirectArgumentBuffer[1], 1, index);
				_RWVisibleInstancesIndexBuffer[index] = instanceIndex;
			}
		}
	}
}